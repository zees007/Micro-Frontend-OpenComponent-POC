"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _icssUtils = require("icss-utils");

var _findLastIndex = require("lodash/findLastIndex");

var _findLastIndex2 = _interopRequireDefault(_findLastIndex);

var _dropWhile = require("lodash/dropWhile");

var _dropWhile2 = _interopRequireDefault(_dropWhile);

var _dropRightWhile = require("lodash/dropRightWhile");

var _dropRightWhile2 = _interopRequireDefault(_dropRightWhile);

var _fromPairs = require("lodash/fromPairs");

var _fromPairs2 = _interopRequireDefault(_fromPairs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint-env node */


var plugin = "postcss-icss-values";

var chunkBy = function chunkBy(collection, iteratee) {
  return collection.reduce(function (acc, item) {
    return iteratee(item) ? [].concat(_toConsumableArray(acc), [[]]) : [].concat(_toConsumableArray(acc.slice(0, -1)), [[].concat(_toConsumableArray(acc[acc.length - 1]), [item])]);
  }, [[]]);
};

var isWord = function isWord(node) {
  return node.type === "word";
};

var isDiv = function isDiv(node) {
  return node.type === "div";
};

var isSpace = function isSpace(node) {
  return node.type === "space";
};

var isNotSpace = function isNotSpace(node) {
  return !isSpace(node);
};

var isFromWord = function isFromWord(node) {
  return isWord(node) && node.value === "from";
};

var isAsWord = function isAsWord(node) {
  return isWord(node) && node.value === "as";
};

var isComma = function isComma(node) {
  return isDiv(node) && node.value === ",";
};

var isColon = function isColon(node) {
  return isDiv(node) && node.value === ":";
};

var isInitializer = function isInitializer(node) {
  return isColon(node) || isSpace(node);
};

var trimNodes = function trimNodes(nodes) {
  return (0, _dropWhile2.default)((0, _dropRightWhile2.default)(nodes, isSpace), isSpace);
};

var getPathValue = function getPathValue(nodes) {
  return nodes.length === 1 && nodes[0].type === "string" ? nodes[0].value : null;
};

var expandValuesParentheses = function expandValuesParentheses(nodes) {
  return nodes.length === 1 && nodes[0].type === "function" && nodes[0].value === "" ? nodes[0].nodes : nodes;
};

var getAliasesPairs = function getAliasesPairs(valuesNodes) {
  return chunkBy(expandValuesParentheses(valuesNodes), isComma).map(function (pairNodes) {
    var nodes = pairNodes.filter(isNotSpace);
    if (nodes.length === 1 && isWord(nodes[0])) {
      return [nodes[0].value, nodes[0].value];
    }
    if (nodes.length === 3 && isWord(nodes[0]) && isAsWord(nodes[1]) && isWord(nodes[2])) {
      return [nodes[0].value, nodes[2].value];
    }
    return null;
  });
};

var parse = function parse(value) {
  var parsed = (0, _postcssValueParser2.default)(value).nodes;
  var fromIndex = (0, _findLastIndex2.default)(parsed, isFromWord);
  if (fromIndex === -1) {
    if (parsed.length > 2 && isWord(parsed[0]) && isInitializer(parsed[1])) {
      return {
        type: "value",
        name: parsed[0].value,
        value: _postcssValueParser2.default.stringify(trimNodes(parsed.slice(2)))
      };
    }
    return null;
  }
  var pairs = getAliasesPairs(trimNodes(parsed.slice(0, fromIndex)));
  var path = getPathValue(trimNodes(parsed.slice(fromIndex + 1)));
  if (pairs.every(Boolean) && path) {
    return {
      type: "import",
      pairs,
      path
    };
  }
  return null;
};

var isForbidden = function isForbidden(name) {
  return name.includes(".") || name.includes("#");
};

var createGenerator = function createGenerator() {
  var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function (name) {
    return `__value__${name.replace(/\W/g, "_")}__${i++}`;
  };
};

var getScopedAliases = function getScopedAliases(messages, values) {
  return (0, _fromPairs2.default)(messages.filter(function (msg) {
    return msg.type === "icss-scoped";
  }).map(function (msg) {
    return [msg.value, values[msg.name]];
  }));
};

var getMessages = function getMessages(exports) {
  return Object.keys(exports).map(function (name) {
    return {
      plugin: "postcss-icss-values",
      type: "icss-value",
      name,
      value: exports[name]
    };
  });
};

module.exports = _postcss2.default.plugin(plugin, function () {
  return function (css, result) {
    var _result$messages;

    var _extractICSS = (0, _icssUtils.extractICSS)(css),
        icssImports = _extractICSS.icssImports,
        icssExports = _extractICSS.icssExports;

    var valuesExports = {};
    var getAliasName = createGenerator();
    var addExports = function addExports(node, name, value) {
      if (isForbidden(name)) {
        result.warn(`Dot and hash symbols are not allowed in value "${name}"`, {
          node
        });
      }
      if (valuesExports[name]) {
        result.warn(`"${name}" value already declared`, { node });
      }
      valuesExports[name] = (0, _icssUtils.replaceValueSymbols)(value, valuesExports);
    };

    css.walkAtRules("value", function (atrule) {
      if (atrule.params.indexOf("@value") !== -1) {
        result.warn(`Invalid value definition "${atrule.params}"`, {
          node: atrule
        });
      } else {
        var parsed = parse(atrule.params);
        if (parsed) {
          if (parsed.type === "value") {
            var name = parsed.name,
                value = parsed.value;

            addExports(atrule, name, value);
          }
          if (parsed.type === "import") {
            var pairs = parsed.pairs.map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  imported = _ref2[0],
                  local = _ref2[1];

              var alias = getAliasName(local);
              addExports(atrule, local, alias);
              return [alias, imported];
            });
            var aliases = (0, _fromPairs2.default)(pairs);
            icssImports[parsed.path] = Object.assign({}, icssImports[parsed.path], aliases);
          }
        } else {
          result.warn(`Invalid value definition "${atrule.params}"`, {
            node: atrule
          });
        }
      }
      atrule.remove();
    });

    var scopedAliases = getScopedAliases(result.messages, valuesExports);

    (0, _icssUtils.replaceSymbols)(css, Object.assign({}, valuesExports, scopedAliases));

    Object.keys(icssExports).forEach(function (key) {
      icssExports[key] = (0, _icssUtils.replaceValueSymbols)(icssExports[key], scopedAliases);
    });

    css.prepend((0, _icssUtils.createICSSRules)(icssImports, Object.assign({}, icssExports, valuesExports)));

    (_result$messages = result.messages).push.apply(_result$messages, _toConsumableArray(getMessages(valuesExports)));
  };
});